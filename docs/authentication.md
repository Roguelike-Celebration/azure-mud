# Authentication
This is a general overview to how authentication works, following the 2024 migration to passwordless 'magic' emails.

## A token
An authentication token is a string cryptographically generated by the server based on the time, user ID, and a secret (a random UUID we store in Redis). 

We do not store tokens at all on the server (i.e. they're not in Redis), they are validated purely cryptographically. 

They do have an expiration date, which we can set.

## A user ID
Since the client has access to the userIds of every logged-in user, we should not use emails as user IDs so as to avoid making email addresses more or less public. This is annoying, but such is software.

When we generate a magic link, we check an email -> userId map in Redis to see if we've generated a user ID yet. If not, generate a GUID, store it, and use that in the magic link so that the client stores that userId when logging in.

We could instead use a one-way hash function to generate userIds. Generating UUIDs instead should make it easier to build a tool to manually associate old accounts with new accounts, since we can just create a mapping from an old user ID to an email address and it should just work.


## An authenticated network request
A valid authenticated HTTP request is defined as having the following two headers:
- `Authorization: Bearer [token]`
- `userId: [userId]`

## The server's perspective
Whenever a HTTP request hits an endpoint requiring authentication, it gets passed through the `authenticate()` middleware function to validate it is a valid, non-expired token for the matching user ID. If it is not, an error is returned.^1

(we do not have a "proper" middleware system, it's just a function that gets called as part of our Azure or Express function wrapping).

Whenever a token is created or validated, it fetches the token secret from Redis. If a secret is not found, a random UUID will be generated and stored in Redis. Since tokens are short-lived, if this secret ends up getting cycled, that will silently invalidate current tokens and simply require people to login again.

There is also a dedicated endpoint, `/sendMagicEmail`, that, given an email address/user ID, sends that email address a message containing a link to the client that embeds a valid token within it.

^1: The `/updateProfile` endpoint is unique and weird. Since it is both used to create a new user profile and update an existing user profile, it is accessed by both logged-in and logged-out users, so its use of the `authenticate` functions is non-standard. Refactoring that into two endpoints is potential future work, albeit with little practical payoff.

## The client's perspective
The client's current token will be stored in localStorage. On app load, we will try to populate React app state with that token.

If there is no token, we will present a logged out state, prompting the user to enter their email address and receive a magic link.

If the page is loaded with query params for a token and a user ID, those will be stored in localStorage, and the page reloaded, allowing the app to load as if the user is logged in.

If the page is loaded with a token in localStorage, we will load the app as normal as if there is a logged-in user.

When the user is logged in, all network requests will inject the correct authentication headers, grabbing that data from React state.

If at any time a network request fails in such a way that indicates an invalid token (most likely due to token expiration), we simply delete the token from localStorage and reset the page, essentially resetting the app to a logged-out state. Ideally we would silently refresh tokens, but I do not believe `easy-no-password` gives us a way to distinguish between invalid tokens and valid-but-expired tokens, so this is fine for now.