# Authentication
This is a general overview to how authentication works, following the 2024 migration to passwordless 'magic' emails.

## A token
An authentication token is a string cryptographically generated by the server based on the time, user ID, and a secret (a random UUID we store in Redis). 

We do not store tokens at all on the server (i.e. they're not in Redis), they are validated purely cryptographically. 

They do have an expiration date, which we can set.

## A user ID
User IDs are email addresses. We have non-email user IDs floating around the production database from legacy users; we will want to find a migration path.

This decision was purely made for convenience, as it greatly simplifies magic email logic if we don't need to translate between internal user IDs and email addresses. Since we do not have a concept of changing someone's email but persisting their account outside of migrating old user accounts, this is unlikely to lead to issues.

TODO: I'm not sure we're not actually better off generating unique UUIDs distinct from emails. Think about this more.

## An authenticated network request
A valid authenticated HTTP request is defined as having the following two headers:
- `Authorization: Bearer [token]`
- `userId: [userId]`

## The server's perspective
Whenever a HTTP request hits an endpoint requiring authentication, it gets passed through the `authenticate()` middleware function to validate it is a valid, non-expired token for the matching user ID. If it is not, an error is returned.^1

(we do not have a "proper" middleware system, it's just a function that gets called as part of our Azure or Express function wrapping).

Whenever a token is created or validated, it fetches the token secret from Redis. If a secret is not found, a random UUID will be generated and stored in Redis. Since tokens are short-lived, if this secret ends up getting cycled, that will silently invalidate current tokens and simply require people to login again.

There is also a dedicated endpoint, `/sendMagicEmail`, that, given an email address/user ID, sends that email address a message containing a link to the client that embeds a valid token within it.

^1: The `/updateProfile` endpoint is unique and weird. Since it is both used to create a new user profile and update an existing user profile, it is accessed by both logged-in and logged-out users, so its use of the `authenticate` functions is non-standard. Refactoring that into two endpoints is potential future work, albeit with little practical payoff.

## The client's perspective
The client's current token will be stored in localStorage. On app load, we will try to populate React app state with that token.

If there is no token, we will present a logged out state, prompting the user to enter their email address and receive a magic link.

If the page is loaded with query params for a token and a user ID, those will be stored in localStorage, and the page reloaded, allowing the app to load as if the user is logged in.

If the page is loaded with a token in localStorage, we will load the app as normal as if there is a logged-in user.

When the user is logged in, all network requests will inject the correct authentication headers, grabbing that data from React state.

If at any time a network request fails in such a way that indicates an invalid token (most likely due to token expiration), we simply delete the token from localStorage and reset the page, essentially resetting the app to a logged-out state. Ideally we would silently refresh tokens, but I do not believe `easy-no-password` gives us a way to distinguish between invalid tokens and valid-but-expired tokens, so this is fine for now.